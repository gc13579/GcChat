一:鉴于上一版聊天App太low,打算重新翻新聊天App,来一次较大换血.
	(1)上一版:由于那时不会使用数据库,因此账号密码保存在文件,读取较困难,登录后所有人即进入一个"主群"
		且无法保留聊天记录.
	(2)此次:所有数据都保存在服务器端数据库.登录成功后进入类似QQ的界面,分为消息、好友、个人中心导航栏.
		用户可搜索其它用户,并发送好友申请,对方同意后可进行聊天.下线后,若好友发送信息,上线后也能查看.
二:设计过程
	(1)摒弃绝大部分上一版本代码,只保留c/s的服务器思想.
	(2)使用数据库是很频繁的操作,因此把获取数据库连接的方法写在util包类,采用ThreadLocal存储数据库连接;再采用三层的思想,对代码分层处理.
	(3)犯的一个大错:按理应是客户端与服务器通信,服务器对数据入库出库,再将结果返回给客户端.而错误之处在于,客户端直接获取数据库连接,
		操作数据库.
三:遇到的问题、错误和解决
	(1)若服务器处于关闭状态,此时登录或注册,由于客户端通过socket向服务器传递数据,此时socket的ip取不到,app闪退,在new Socket(ip,port)时,
		应抛出异常给客户端调用处,catch到异常后,给用户一个:服务器正忙,之类的提示.
	(2)为让用户感觉友好,在登录时,显示旋转进度条,提示用户正在登录.登录时,客户端通过socket向服务器传递账号密码,此耗时操作若在主线程进行,
		主线程直接卡住,从android4开始,耗时操作就不应在主线程执行.因此,第一次的想法是new一个thread执行,但是两个线程会争夺cpu,若使用join
		让子线程先执行,则阻塞了主线程,这种行为欠妥.由此引发出android自带的一个异步线程类AsyncTask,使用这个类，可在不阻塞主线程的情况,另外
		开辟一个子线程,进行耗时操作,如获取socket连接,io操作等,至此解决了第一个大难题.
	(3)查询并添加好友,查询到用户后,向目标人[下称拟好友]发送一条消息.问题在于:1.无法确认拟好友是否在线,2.若拟好友在线,无论拟好友在干什么
		(在QQ中,如刷空间、聊天、看热点等),都应能收到好友请求.针对上述2个问题,考虑将好友请求入库,再从在线socket集合中根据拟好友id获取socket,
		在线套接字集合为map<Integer,Socket>形式,若对方不在线,则无后续操作,拟好友上线后,查询一次有无好友请求即可.若拟好友在线,拟好友在登录
		成功后,需开启一个service,service运行在android后台，和Activity不同,service没有界面,service负责接收服务器的数据,以及发送一些广播,
		拟好友登录后再开启一些广播监听,其中一个就是监听是否有好友请求,若监听到请求,则在好友tab和好友fragment的新朋友按钮处,显示红点以及
		播放音乐提醒拟好友.使用service、广播即解决了,无论用户在干什么,都能收到好友请求.至此解决了第二个大难题.
	(4)聊天,与上面类似.无法确认好友是否在线,好友在线时,无论在哪个页面都应收到消息,故仍然在登录成功时,开启service和广播监听.重点在于,下线后
		再次上线,之前的聊天记录需仍然显示,故A给B发消息时,会判断B是否在线,在线的话,最近[在线]联系人表中添加一条记录;不在线时,下线联系人表添加
		一条记录,B登录后,查询两个表,再将结果汇总,得出与自己聊天的好友,再将好友id传入聊天记录表得出消息导航栏要显示的,所有消息.同时,删除下线
		联系人表中的数据,防止下一次登录再次查询到.[注:最近联系人和下线联系人表,记录的添加方式在服务器端采用了两个List分别存储,要添加时遍历
		List中的数据,要添加的数据和List中的不一致,才可进入数据库,此方案可防止添加大量重复数据]
	(5)删除好友,删除后聊天记录仍然存在.在删除后,应及时把聊天记录表、最近联系人、下线联系人表数据清空,同时,清空上述两个List,若不清空List,在没有
		下线的情况下再次添加该好友,由于List还存在与该好友的记录,故不再向最近联系人表添加记录,由于之前又将记录删除,导致无法看见与好友的聊天.
		
		
	
	